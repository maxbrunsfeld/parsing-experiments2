use crate::{util::strncmp, *};

use std::{os, ptr};

/// Get the number of distinct node types in the language.
#[no_mangle]
pub unsafe extern "C" fn ts_language_symbol_count(mut self_0: *const TSLanguage) -> u32 {
    (*self_0).symbol_count.wrapping_add((*self_0).alias_count)
}

/// Get the ABI version number for this language. This version number is used
/// to ensure that languages were generated by a compatible version of
/// Tree-sitter.
///
/// See also `ts_parser_set_language`.
#[no_mangle]
pub unsafe extern "C" fn ts_language_version(mut self_0: *const TSLanguage) -> u32 {
    (*self_0).version
}

/// Get the number of distinct field names in the language.
#[no_mangle]
pub unsafe extern "C" fn ts_language_field_count(mut self_0: *const TSLanguage) -> u32 {
    if (*self_0).version >= 10 as os::raw::c_int as os::raw::c_uint {
        (*self_0).field_count
    } else {
        0 as os::raw::c_int as u32
    }
}
#[no_mangle]
pub(crate) unsafe extern "C" fn ts_language_table_entry(
    mut self_0: *const TSLanguage,
    mut state: TSStateId,
    mut symbol: TSSymbol,
    mut result: *mut TableEntry,
) {
    if symbol as os::raw::c_int == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int
        || symbol as os::raw::c_int
            == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int - 1 as os::raw::c_int
    {
        (*result).action_count = 0 as os::raw::c_int as u32;
        (*result).is_reusable = false;
        (*result).actions = std::ptr::null::<TSParseAction>()
    } else {
        assert!((symbol as os::raw::c_uint) < (*self_0).token_count);
        let mut action_index: u32 = ts_language_lookup(self_0, state, symbol) as u32;
        let mut entry: *const TSParseActionEntry =
            &*(*self_0).parse_actions.offset(action_index as isize) as *const TSParseActionEntry;
        (*result).action_count = (*entry).entry.count as u32;
        (*result).is_reusable = (*entry).entry.reusable();
        (*result).actions = entry.offset(1 as os::raw::c_int as isize) as *const TSParseAction
    };
}
#[no_mangle]
pub(crate) unsafe extern "C" fn ts_language_symbol_metadata(
    mut self_0: *const TSLanguage,
    mut symbol: TSSymbol,
) -> TSSymbolMetadata {
    if symbol as os::raw::c_int == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int {
        let mut init = TSSymbolMetadata {
            visible_named: [0; 1],
        };
        init.set_visible(true);
        init.set_named(true);
        init
    } else if symbol as os::raw::c_int
        == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int - 1 as os::raw::c_int
    {
        let mut init = TSSymbolMetadata {
            visible_named: [0; 1],
        };
        init.set_visible(false);
        init.set_named(false);
        init
    } else {
        *(*self_0).symbol_metadata.offset(symbol as isize)
    }
}
#[no_mangle]
pub(crate) unsafe extern "C" fn ts_language_public_symbol(
    mut self_0: *const TSLanguage,
    mut symbol: TSSymbol,
) -> TSSymbol {
    if symbol as os::raw::c_int == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int {
        symbol
    } else if (*self_0).version >= 11 as os::raw::c_int as os::raw::c_uint {
        *(*self_0).public_symbol_map.offset(symbol as isize)
    } else {
        symbol
    }
}

/// Get a node type string for the given numerical id.
#[no_mangle]
pub unsafe extern "C" fn ts_language_symbol_name(
    mut self_0: *const TSLanguage,
    mut symbol: TSSymbol,
) -> *const os::raw::c_char {
    if symbol as os::raw::c_int == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int {
        b"ERROR\x00" as *const u8 as *const os::raw::c_char
    } else if symbol as os::raw::c_int
        == -(1 as os::raw::c_int) as TSSymbol as os::raw::c_int - 1 as os::raw::c_int
    {
        b"_ERROR\x00" as *const u8 as *const os::raw::c_char
    } else if (symbol as os::raw::c_uint) < ts_language_symbol_count(self_0) {
        *(*self_0).symbol_names.offset(symbol as isize)
    } else {
        ptr::null()
    }
}

/// Get the numerical id for the given node type string.
#[no_mangle]
pub unsafe extern "C" fn ts_language_symbol_for_name(
    mut self_0: *const TSLanguage,
    mut string: *const os::raw::c_char,
    mut length: u32,
    mut is_named: bool,
) -> TSSymbol {
    if strncmp(
        string,
        b"ERROR\x00" as *const u8 as *const os::raw::c_char,
        length as usize,
    ) == 0
    {
        return -(1 as os::raw::c_int) as TSSymbol;
    }
    let mut count: u32 = ts_language_symbol_count(self_0);
    let mut i: TSSymbol = 0 as os::raw::c_int as TSSymbol;
    while (i as os::raw::c_uint) < count {
        let mut metadata: TSSymbolMetadata = ts_language_symbol_metadata(self_0, i);
        if metadata.visible() && metadata.named() as os::raw::c_int == is_named as os::raw::c_int {
            let mut symbol_name: *const os::raw::c_char =
                *(*self_0).symbol_names.offset(i as isize);
            if strncmp(symbol_name, string, length as usize) == 0
                && *symbol_name.offset(length as isize) == 0
            {
                if (*self_0).version >= 11 as os::raw::c_int as os::raw::c_uint {
                    return *(*self_0).public_symbol_map.offset(i as isize);
                } else {
                    return i;
                }
            }
        }
        i = i.wrapping_add(1)
    }
    0 as os::raw::c_int as TSSymbol
}

/// Check whether the given node type id belongs to named nodes, anonymous nodes,
/// or a hidden nodes.
///
/// See also `ts_node_is_named`. Hidden nodes are never returned from the API.
#[no_mangle]
pub unsafe extern "C" fn ts_language_symbol_type(
    mut self_0: *const TSLanguage,
    mut symbol: TSSymbol,
) -> TSSymbolType {
    let mut metadata: TSSymbolMetadata = ts_language_symbol_metadata(self_0, symbol);
    if metadata.named() {
        TSSymbolTypeRegular
    } else if metadata.visible() {
        TSSymbolTypeAnonymous
    } else {
        TSSymbolTypeAuxiliary
    }
}

/// Get the field name string for the given numerical id.
#[no_mangle]
pub unsafe extern "C" fn ts_language_field_name_for_id(
    mut self_0: *const TSLanguage,
    mut id: TSFieldId,
) -> *const os::raw::c_char {
    let mut count: u32 = ts_language_field_count(self_0);
    if count != 0 && id as os::raw::c_uint <= count {
        *(*self_0).field_names.offset(id as isize)
    } else {
        ptr::null()
    }
}

/// Get the numerical id for the given field name string.
#[no_mangle]
pub unsafe extern "C" fn ts_language_field_id_for_name(
    mut self_0: *const TSLanguage,
    mut name: *const os::raw::c_char,
    mut name_length: u32,
) -> TSFieldId {
    let mut count: u32 = ts_language_field_count(self_0);
    let mut i: TSSymbol = 1 as os::raw::c_int as TSSymbol;
    while (i as os::raw::c_uint) < count.wrapping_add(1) {
        match strncmp(
            name,
            *(*self_0).field_names.offset(i as isize),
            name_length as usize,
        ) {
            0 => {
                if *(*(*self_0).field_names.offset(i as isize)).offset(name_length as isize)
                    as os::raw::c_int
                    == 0 as os::raw::c_int
                {
                    return i;
                }
            }
            -1 => return 0 as os::raw::c_int as TSFieldId,
            _ => {}
        }
        i = i.wrapping_add(1)
    }
    0 as os::raw::c_int as TSFieldId
}
